

/****************************************************************************
 *
 *   Copyright (c) 2015 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file topic_listener.cpp
 *
 * Autogenerated by Tools/generate_listener.py
 *
 * Tool for listening to topics when running flight stack on linux.
 */

#include <drivers/drv_hrt.h>
#include <px4_middleware.h>
#include <px4_app.h>
#include <px4_config.h>
#include <uORB/uORB.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifndef PRIu64
#define PRIu64 "llu"
#endif

#ifndef PRId64
#define PRId64 "lld"
#endif

static bool check_timeout(const hrt_abstime& time) {
    if (hrt_elapsed_time(&time) > 2*1000*1000) {
		printf("Waited for 2 seconds without a message. Giving up.\n");
        return true;
    }
    return false;
}


#include <uORB/topics/sensor_accel.h>
#include <uORB/topics/manual_control_setpoint.h>
#include <uORB/topics/adc_report.h>
#include <uORB/topics/estimator_status.h>
#include <uORB/topics/telemetry_status.h>
#include <uORB/topics/debug_vect.h>
#include <uORB/topics/vehicle_gps_position.h>
#include <uORB/topics/vehicle_attitude.h>
#include <uORB/topics/sensor_baro.h>
#include <uORB/topics/sensor_correction.h>
#include <uORB/topics/differential_pressure.h>
#include <uORB/topics/camera_trigger.h>
#include <uORB/topics/hil_sensor.h>
#include <uORB/topics/filtered_bottom_flow.h>
#include <uORB/topics/mission.h>
#include <uORB/topics/actuator_direct.h>
#include <uORB/topics/multirotor_motor_limits.h>
#include <uORB/topics/vehicle_status_flags.h>
#include <uORB/topics/vehicle_force_setpoint.h>
#include <uORB/topics/geofence_result.h>
#include <uORB/topics/safety.h>
#include <uORB/topics/ekf2_innovations.h>
#include <uORB/topics/subsystem_info.h>
#include <uORB/topics/vehicle_command.h>
#include <uORB/topics/rc_parameter_map.h>
#include <uORB/topics/home_position.h>
#include <uORB/topics/collision_report.h>
#include <uORB/topics/transponder_report.h>
#include <uORB/topics/gps_dump.h>
#include <uORB/topics/esc_report.h>
#include <uORB/topics/ulog_stream_ack.h>
#include <uORB/topics/mount_orientation.h>
#include <uORB/topics/tecs_status.h>
#include <uORB/topics/sensor_preflight.h>
#include <uORB/topics/sensor_selection.h>
#include <uORB/topics/input_rc.h>
#include <uORB/topics/vtol_vehicle_status.h>
#include <uORB/topics/uavcan_parameter_request.h>
#include <uORB/topics/power_button_state.h>
#include <uORB/topics/airspeed.h>
#include <uORB/topics/cpuload.h>
#include <uORB/topics/debug_key_value.h>
#include <uORB/topics/vehicle_local_position.h>
#include <uORB/topics/gps_inject_data.h>
#include <uORB/topics/uavcan_parameter_value.h>
#include <uORB/topics/time_offset.h>
#include <uORB/topics/task_stack_info.h>
#include <uORB/topics/commander_state.h>
#include <uORB/topics/rc_channels.h>
#include <uORB/topics/satellite_info.h>
#include <uORB/topics/log_message.h>
#include <uORB/topics/test_motor.h>
#include <uORB/topics/qshell_req.h>
#include <uORB/topics/fw_pos_ctrl_status.h>
#include <uORB/topics/camera_capture.h>
#include <uORB/topics/servorail_status.h>
#include <uORB/topics/offboard_control_mode.h>
#include <uORB/topics/sensor_gyro.h>
#include <uORB/topics/vehicle_rates_setpoint.h>
#include <uORB/topics/parameter_update.h>
#include <uORB/topics/mavlink_log.h>
#include <uORB/topics/sensor_combined.h>
#include <uORB/topics/vehicle_command_ack.h>
#include <uORB/topics/esc_status.h>
#include <uORB/topics/debug_value.h>
#include <uORB/topics/system_power.h>
#include <uORB/topics/sensor_mag.h>
#include <uORB/topics/vehicle_global_position.h>
#include <uORB/topics/battery_status.h>
#include <uORB/topics/vehicle_roi.h>
#include <uORB/topics/distance_sensor.h>
#include <uORB/topics/att_pos_mocap.h>
#include <uORB/topics/led_control.h>
#include <uORB/topics/vehicle_status.h>
#include <uORB/topics/vehicle_land_detected.h>
#include <uORB/topics/vehicle_attitude_setpoint.h>
#include <uORB/topics/actuator_armed.h>
#include <uORB/topics/ulog_stream.h>
#include <uORB/topics/vehicle_control_mode.h>
#include <uORB/topics/follow_target.h>
#include <uORB/topics/mc_att_ctrl_status.h>
#include <uORB/topics/wind_estimate.h>
#include <uORB/topics/ekf2_timestamps.h>
#include <uORB/topics/optical_flow.h>
#include <uORB/topics/mission_result.h>
#include <uORB/topics/output_pwm.h>
#include <uORB/topics/sensor_bias.h>
#include <uORB/topics/actuator_outputs.h>

extern "C" __EXPORT int listener_main(int argc, char *argv[]);

int listener_main(int argc, char *argv[]) {
	int sub = -1;
	orb_id_t ID;
	if(argc < 2) {
		printf("need at least two arguments: topic name. [optional number of messages to print] [optional instance]\n");
		return 1;
	}

	unsigned num_msgs = (argc > 2) ? atoi(argv[2]) : 1;
	unsigned topic_instance = (argc > 3) ? atoi(argv[3]) : 0;
	if (strncmp(argv[1],"sensor_accel",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_accel), topic_instance);
		ID = ORB_ID(sensor_accel);
		struct sensor_accel_s container;
		memset(&container, 0, sizeof(container));
	} else if (strncmp(argv[1],"manual_control_setpoint",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(manual_control_setpoint), topic_instance);
		ID = ORB_ID(manual_control_setpoint);
		struct manual_control_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: manual_control_setpoint instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("r: %8.4f\n",(double)container.r);
			printf("flaps: %8.4f\n",(double)container.flaps);
			printf("aux1: %8.4f\n",(double)container.aux1);
			printf("aux2: %8.4f\n",(double)container.aux2);
			printf("aux3: %8.4f\n",(double)container.aux3);
			printf("aux4: %8.4f\n",(double)container.aux4);
			printf("aux5: %8.4f\n",(double)container.aux5);
			printf("mode_switch: %u\n",(unsigned)container.mode_switch);
			printf("return_switch: %u\n",(unsigned)container.return_switch);
			printf("rattitude_switch: %u\n",(unsigned)container.rattitude_switch);
			printf("posctl_switch: %u\n",(unsigned)container.posctl_switch);
			printf("loiter_switch: %u\n",(unsigned)container.loiter_switch);
			printf("acro_switch: %u\n",(unsigned)container.acro_switch);
			printf("offboard_switch: %u\n",(unsigned)container.offboard_switch);
			printf("kill_switch: %u\n",(unsigned)container.kill_switch);
			printf("arm_switch: %u\n",(unsigned)container.arm_switch);
			printf("transition_switch: %u\n",(unsigned)container.transition_switch);
			printf("gear_switch: %u\n",(unsigned)container.gear_switch);
			printf("mode_slot: %d\n",(int)container.mode_slot);
			printf("data_source: %u\n",(unsigned)container.data_source);
			printf("stab_switch: %u\n",(unsigned)container.stab_switch);
			printf("man_switch: %u\n",(unsigned)container.man_switch);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"adc_report",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(adc_report), topic_instance);
		ID = ORB_ID(adc_report);
		struct adc_report_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: adc_report instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("channel_id: ");
			for (int j = 0; j < 12; j++) {
				printf("%d ",container.channel_id[j]);
			}
			printf("\n");
			printf("channel_value: ");
			for (int j = 0; j < 12; j++) {
				printf("%8.4f ",(double)container.channel_value[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"estimator_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(estimator_status), topic_instance);
		ID = ORB_ID(estimator_status);
		struct estimator_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: estimator_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("states: ");
			for (int j = 0; j < 24; j++) {
				printf("%8.4f ",(double)container.states[j]);
			}
			printf("\n");
			printf("n_states: %8.4f\n",(double)container.n_states);
			printf("vibe: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.vibe[j]);
			}
			printf("\n");
			printf("nan_flags: %u\n",(unsigned)container.nan_flags);
			printf("health_flags: %u\n",(unsigned)container.health_flags);
			printf("timeout_flags: %u\n",(unsigned)container.timeout_flags);
			printf("covariances: ");
			for (int j = 0; j < 24; j++) {
				printf("%8.4f ",(double)container.covariances[j]);
			}
			printf("\n");
			printf("gps_check_fail_flags: %u\n",(unsigned)container.gps_check_fail_flags);
			printf("control_mode_flags: %u\n",container.control_mode_flags);
			printf("filter_fault_flags: %u\n",(unsigned)container.filter_fault_flags);
			printf("pos_horiz_accuracy: %8.4f\n",(double)container.pos_horiz_accuracy);
			printf("pos_vert_accuracy: %8.4f\n",(double)container.pos_vert_accuracy);
			printf("innovation_check_flags: %u\n",(unsigned)container.innovation_check_flags);
			printf("mag_test_ratio: %8.4f\n",(double)container.mag_test_ratio);
			printf("vel_test_ratio: %8.4f\n",(double)container.vel_test_ratio);
			printf("pos_test_ratio: %8.4f\n",(double)container.pos_test_ratio);
			printf("hgt_test_ratio: %8.4f\n",(double)container.hgt_test_ratio);
			printf("tas_test_ratio: %8.4f\n",(double)container.tas_test_ratio);
			printf("hagl_test_ratio: %8.4f\n",(double)container.hagl_test_ratio);
			printf("solution_status_flags: %u\n",(unsigned)container.solution_status_flags);
			printf("time_slip: %8.4f\n",(double)container.time_slip);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"telemetry_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(telemetry_status), topic_instance);
		ID = ORB_ID(telemetry_status);
		struct telemetry_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: telemetry_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("heartbeat_time: %" PRIu64 "\n",container.heartbeat_time);
			printf("telem_time: %" PRIu64 "\n",container.telem_time);
			printf("type: %u\n",(unsigned)container.type);
			printf("rssi: %u\n",(unsigned)container.rssi);
			printf("remote_rssi: %u\n",(unsigned)container.remote_rssi);
			printf("rxerrors: %u\n",(unsigned)container.rxerrors);
			printf("fixed: %u\n",(unsigned)container.fixed);
			printf("noise: %u\n",(unsigned)container.noise);
			printf("remote_noise: %u\n",(unsigned)container.remote_noise);
			printf("txbuf: %u\n",(unsigned)container.txbuf);
			printf("system_id: %u\n",(unsigned)container.system_id);
			printf("component_id: %u\n",(unsigned)container.component_id);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"debug_vect",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(debug_vect), topic_instance);
		ID = ORB_ID(debug_vect);
		struct debug_vect_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: debug_vect instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_us: %" PRIu64 "\n",container.timestamp_us);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_gps_position",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_gps_position), topic_instance);
		ID = ORB_ID(vehicle_gps_position);
		struct vehicle_gps_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_gps_position instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("lat: %d\n",container.lat);
			printf("lon: %d\n",container.lon);
			printf("alt: %d\n",container.alt);
			printf("alt_ellipsoid: %d\n",container.alt_ellipsoid);
			printf("s_variance_m_s: %8.4f\n",(double)container.s_variance_m_s);
			printf("c_variance_rad: %8.4f\n",(double)container.c_variance_rad);
			printf("fix_type: %u\n",(unsigned)container.fix_type);
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			printf("hdop: %8.4f\n",(double)container.hdop);
			printf("vdop: %8.4f\n",(double)container.vdop);
			printf("noise_per_ms: %d\n",container.noise_per_ms);
			printf("jamming_indicator: %d\n",container.jamming_indicator);
			printf("vel_m_s: %8.4f\n",(double)container.vel_m_s);
			printf("vel_n_m_s: %8.4f\n",(double)container.vel_n_m_s);
			printf("vel_e_m_s: %8.4f\n",(double)container.vel_e_m_s);
			printf("vel_d_m_s: %8.4f\n",(double)container.vel_d_m_s);
			printf("cog_rad: %8.4f\n",(double)container.cog_rad);
			printf("vel_ned_valid: %s\n",container.vel_ned_valid ? "True" : "False");
			printf("time_utc_usec: %" PRIu64 "\n",container.time_utc_usec);
			printf("satellites_used: %u\n",(unsigned)container.satellites_used);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_attitude",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_attitude), topic_instance);
		ID = ORB_ID(vehicle_attitude);
		struct vehicle_attitude_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_attitude instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("rollspeed: %8.4f\n",(double)container.rollspeed);
			printf("pitchspeed: %8.4f\n",(double)container.pitchspeed);
			printf("yawspeed: %8.4f\n",(double)container.yawspeed);
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			printf("delta_q_reset: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.delta_q_reset[j]);
			}
			printf("\n");
			printf("quat_reset_counter: %u\n",(unsigned)container.quat_reset_counter);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_baro",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_baro), topic_instance);
		ID = ORB_ID(sensor_baro);
		struct sensor_baro_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_baro instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("pressure: %8.4f\n",(double)container.pressure);
			printf("altitude: %8.4f\n",(double)container.altitude);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("device_id: %u\n",container.device_id);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_correction",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_correction), topic_instance);
		ID = ORB_ID(sensor_correction);
		struct sensor_correction_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_correction instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("gyro_offset_0: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_offset_0[j]);
			}
			printf("\n");
			printf("gyro_scale_0: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_scale_0[j]);
			}
			printf("\n");
			printf("gyro_offset_1: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_offset_1[j]);
			}
			printf("\n");
			printf("gyro_scale_1: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_scale_1[j]);
			}
			printf("\n");
			printf("gyro_offset_2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_offset_2[j]);
			}
			printf("\n");
			printf("gyro_scale_2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_scale_2[j]);
			}
			printf("\n");
			printf("accel_offset_0: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accel_offset_0[j]);
			}
			printf("\n");
			printf("accel_scale_0: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accel_scale_0[j]);
			}
			printf("\n");
			printf("accel_offset_1: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accel_offset_1[j]);
			}
			printf("\n");
			printf("accel_scale_1: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accel_scale_1[j]);
			}
			printf("\n");
			printf("accel_offset_2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accel_offset_2[j]);
			}
			printf("\n");
			printf("accel_scale_2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accel_scale_2[j]);
			}
			printf("\n");
			printf("baro_offset_0: %8.4f\n",(double)container.baro_offset_0);
			printf("baro_scale_0: %8.4f\n",(double)container.baro_scale_0);
			printf("baro_offset_1: %8.4f\n",(double)container.baro_offset_1);
			printf("baro_scale_1: %8.4f\n",(double)container.baro_scale_1);
			printf("baro_offset_2: %8.4f\n",(double)container.baro_offset_2);
			printf("baro_scale_2: %8.4f\n",(double)container.baro_scale_2);
			printf("selected_gyro_instance: %u\n",(unsigned)container.selected_gyro_instance);
			printf("selected_accel_instance: %u\n",(unsigned)container.selected_accel_instance);
			printf("selected_baro_instance: %u\n",(unsigned)container.selected_baro_instance);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"differential_pressure",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(differential_pressure), topic_instance);
		ID = ORB_ID(differential_pressure);
		struct differential_pressure_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: differential_pressure instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("differential_pressure_raw_pa: %8.4f\n",(double)container.differential_pressure_raw_pa);
			printf("differential_pressure_filtered_pa: %8.4f\n",(double)container.differential_pressure_filtered_pa);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("device_id: %u\n",container.device_id);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"camera_trigger",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(camera_trigger), topic_instance);
		ID = ORB_ID(camera_trigger);
		struct camera_trigger_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: camera_trigger instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_utc: %" PRIu64 "\n",container.timestamp_utc);
			printf("seq: %u\n",container.seq);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"hil_sensor",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(hil_sensor), topic_instance);
		ID = ORB_ID(hil_sensor);
		struct hil_sensor_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: hil_sensor instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("gyro_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.gyro_raw[j]);
			}
			printf("\n");
			printf("gyro_rad_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_rad_s[j]);
			}
			printf("\n");
			printf("gyro_errcount: %u\n",container.gyro_errcount);
			printf("gyro_temp: %8.4f\n",(double)container.gyro_temp);
			printf("accelerometer_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.accelerometer_raw[j]);
			}
			printf("\n");
			printf("accelerometer_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer_mode: %d\n",(int)container.accelerometer_mode);
			printf("accelerometer_range_m_s2: %8.4f\n",(double)container.accelerometer_range_m_s2);
			printf("accelerometer_timestamp: %" PRIu64 "\n",container.accelerometer_timestamp);
			printf("accelerometer_errcount: %u\n",container.accelerometer_errcount);
			printf("accelerometer_temp: %8.4f\n",(double)container.accelerometer_temp);
			printf("magnetometer_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.magnetometer_raw[j]);
			}
			printf("\n");
			printf("magnetometer_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_ga[j]);
			}
			printf("\n");
			printf("magnetometer_mode: %d\n",(int)container.magnetometer_mode);
			printf("magnetometer_range_ga: %8.4f\n",(double)container.magnetometer_range_ga);
			printf("magnetometer_cuttoff_freq_hz: %8.4f\n",(double)container.magnetometer_cuttoff_freq_hz);
			printf("magnetometer_timestamp: %" PRIu64 "\n",container.magnetometer_timestamp);
			printf("magnetometer_errcount: %u\n",container.magnetometer_errcount);
			printf("magnetometer_temp: %8.4f\n",(double)container.magnetometer_temp);
			printf("gyro1_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.gyro1_raw[j]);
			}
			printf("\n");
			printf("gyro1_rad_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro1_rad_s[j]);
			}
			printf("\n");
			printf("gyro1_timestamp: %" PRIu64 "\n",container.gyro1_timestamp);
			printf("gyro1_errcount: %u\n",container.gyro1_errcount);
			printf("gyro1_temp: %8.4f\n",(double)container.gyro1_temp);
			printf("accelerometer1_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.accelerometer1_raw[j]);
			}
			printf("\n");
			printf("accelerometer1_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer1_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer1_timestamp: %" PRIu64 "\n",container.accelerometer1_timestamp);
			printf("accelerometer1_errcount: %u\n",container.accelerometer1_errcount);
			printf("accelerometer1_temp: %8.4f\n",(double)container.accelerometer1_temp);
			printf("magnetometer1_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.magnetometer1_raw[j]);
			}
			printf("\n");
			printf("magnetometer1_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer1_ga[j]);
			}
			printf("\n");
			printf("magnetometer1_timestamp: %" PRIu64 "\n",container.magnetometer1_timestamp);
			printf("magnetometer1_errcount: %u\n",container.magnetometer1_errcount);
			printf("magnetometer1_temp: %8.4f\n",(double)container.magnetometer1_temp);
			printf("gyro2_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.gyro2_raw[j]);
			}
			printf("\n");
			printf("gyro2_rad_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro2_rad_s[j]);
			}
			printf("\n");
			printf("gyro2_timestamp: %" PRIu64 "\n",container.gyro2_timestamp);
			printf("gyro2_errcount: %u\n",container.gyro2_errcount);
			printf("gyro2_temp: %8.4f\n",(double)container.gyro2_temp);
			printf("accelerometer2_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.accelerometer2_raw[j]);
			}
			printf("\n");
			printf("accelerometer2_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer2_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer2_timestamp: %" PRIu64 "\n",container.accelerometer2_timestamp);
			printf("accelerometer2_errcount: %u\n",container.accelerometer2_errcount);
			printf("accelerometer2_temp: %8.4f\n",(double)container.accelerometer2_temp);
			printf("magnetometer2_raw: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.magnetometer2_raw[j]);
			}
			printf("\n");
			printf("magnetometer2_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer2_ga[j]);
			}
			printf("\n");
			printf("magnetometer2_timestamp: %" PRIu64 "\n",container.magnetometer2_timestamp);
			printf("magnetometer2_errcount: %u\n",container.magnetometer2_errcount);
			printf("magnetometer2_temp: %8.4f\n",(double)container.magnetometer2_temp);
			printf("baro_pres_mbar: %8.4f\n",(double)container.baro_pres_mbar);
			printf("baro_alt_meter: %8.4f\n",(double)container.baro_alt_meter);
			printf("baro_temp_celcius: %8.4f\n",(double)container.baro_temp_celcius);
			printf("baro_timestamp: %" PRIu64 "\n",container.baro_timestamp);
			printf("baro1_pres_mbar: %8.4f\n",(double)container.baro1_pres_mbar);
			printf("baro1_alt_meter: %8.4f\n",(double)container.baro1_alt_meter);
			printf("baro1_temp_celcius: %8.4f\n",(double)container.baro1_temp_celcius);
			printf("baro1_timestamp: %" PRIu64 "\n",container.baro1_timestamp);
			printf("adc_voltage_v: ");
			for (int j = 0; j < 10; j++) {
				printf("%8.4f ",(double)container.adc_voltage_v[j]);
			}
			printf("\n");
			printf("adc_mapping: ");
			for (int j = 0; j < 10; j++) {
				printf("%u ",container.adc_mapping[j]);
			}
			printf("\n");
			printf("mcu_temp_celcius: %8.4f\n",(double)container.mcu_temp_celcius);
			printf("differential_pressure_pa: %8.4f\n",(double)container.differential_pressure_pa);
			printf("differential_pressure_timestamp: %" PRIu64 "\n",container.differential_pressure_timestamp);
			printf("differential_pressure_filtered_pa: %8.4f\n",(double)container.differential_pressure_filtered_pa);
			printf("differential_pressure1_pa: %8.4f\n",(double)container.differential_pressure1_pa);
			printf("differential_pressure1_timestamp: %" PRIu64 "\n",container.differential_pressure1_timestamp);
			printf("differential_pressure1_filtered_pa: %8.4f\n",(double)container.differential_pressure1_filtered_pa);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"filtered_bottom_flow",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(filtered_bottom_flow), topic_instance);
		ID = ORB_ID(filtered_bottom_flow);
		struct filtered_bottom_flow_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: filtered_bottom_flow instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("sumx: %8.4f\n",(double)container.sumx);
			printf("sumy: %8.4f\n",(double)container.sumy);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vy: %8.4f\n",(double)container.vy);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"mission",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(mission), topic_instance);
		ID = ORB_ID(mission);
		struct mission_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: mission instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("dataman_id: %d\n",container.dataman_id);
			printf("count: %u\n",container.count);
			printf("current_seq: %d\n",container.current_seq);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"actuator_direct",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(actuator_direct), topic_instance);
		ID = ORB_ID(actuator_direct);
		struct actuator_direct_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: actuator_direct instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("nvalues: %u\n",container.nvalues);
			printf("values: ");
			for (int j = 0; j < 16; j++) {
				printf("%8.4f ",(double)container.values[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"multirotor_motor_limits",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(multirotor_motor_limits), topic_instance);
		ID = ORB_ID(multirotor_motor_limits);
		struct multirotor_motor_limits_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: multirotor_motor_limits instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("saturation_status: %u\n",(unsigned)container.saturation_status);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_status_flags",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_status_flags), topic_instance);
		ID = ORB_ID(vehicle_status_flags);
		struct vehicle_status_flags_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_status_flags instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("conditions: %u\n",(unsigned)container.conditions);
			printf("circuit_breakers: %u\n",(unsigned)container.circuit_breakers);
			printf("other_flags: %u\n",(unsigned)container.other_flags);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_force_setpoint",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_force_setpoint), topic_instance);
		ID = ORB_ID(vehicle_force_setpoint);
		struct vehicle_force_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_force_setpoint instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("yaw: %8.4f\n",(double)container.yaw);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"geofence_result",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(geofence_result), topic_instance);
		ID = ORB_ID(geofence_result);
		struct geofence_result_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: geofence_result instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("geofence_violated: %s\n",container.geofence_violated ? "True" : "False");
			printf("geofence_action: %u\n",(unsigned)container.geofence_action);
			printf("home_required: %s\n",container.home_required ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"safety",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(safety), topic_instance);
		ID = ORB_ID(safety);
		struct safety_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: safety instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("safety_switch_available: %s\n",container.safety_switch_available ? "True" : "False");
			printf("safety_off: %s\n",container.safety_off ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"ekf2_innovations",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(ekf2_innovations), topic_instance);
		ID = ORB_ID(ekf2_innovations);
		struct ekf2_innovations_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: ekf2_innovations instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("vel_pos_innov: ");
			for (int j = 0; j < 6; j++) {
				printf("%8.4f ",(double)container.vel_pos_innov[j]);
			}
			printf("\n");
			printf("mag_innov: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.mag_innov[j]);
			}
			printf("\n");
			printf("heading_innov: %8.4f\n",(double)container.heading_innov);
			printf("airspeed_innov: %8.4f\n",(double)container.airspeed_innov);
			printf("beta_innov: %8.4f\n",(double)container.beta_innov);
			printf("flow_innov: ");
			for (int j = 0; j < 2; j++) {
				printf("%8.4f ",(double)container.flow_innov[j]);
			}
			printf("\n");
			printf("hagl_innov: %8.4f\n",(double)container.hagl_innov);
			printf("vel_pos_innov_var: ");
			for (int j = 0; j < 6; j++) {
				printf("%8.4f ",(double)container.vel_pos_innov_var[j]);
			}
			printf("\n");
			printf("mag_innov_var: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.mag_innov_var[j]);
			}
			printf("\n");
			printf("heading_innov_var: %8.4f\n",(double)container.heading_innov_var);
			printf("airspeed_innov_var: %8.4f\n",(double)container.airspeed_innov_var);
			printf("beta_innov_var: %8.4f\n",(double)container.beta_innov_var);
			printf("flow_innov_var: ");
			for (int j = 0; j < 2; j++) {
				printf("%8.4f ",(double)container.flow_innov_var[j]);
			}
			printf("\n");
			printf("hagl_innov_var: %8.4f\n",(double)container.hagl_innov_var);
			printf("output_tracking_error: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.output_tracking_error[j]);
			}
			printf("\n");
			printf("drag_innov: ");
			for (int j = 0; j < 2; j++) {
				printf("%8.4f ",(double)container.drag_innov[j]);
			}
			printf("\n");
			printf("drag_innov_var: ");
			for (int j = 0; j < 2; j++) {
				printf("%8.4f ",(double)container.drag_innov_var[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"subsystem_info",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(subsystem_info), topic_instance);
		ID = ORB_ID(subsystem_info);
		struct subsystem_info_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: subsystem_info instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("present: %s\n",container.present ? "True" : "False");
			printf("enabled: %s\n",container.enabled ? "True" : "False");
			printf("ok: %s\n",container.ok ? "True" : "False");
			printf("subsystem_type: %" PRIu64 "\n",container.subsystem_type);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_command",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_command), topic_instance);
		ID = ORB_ID(vehicle_command);
		struct vehicle_command_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_command instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("param1: %8.4f\n",(double)container.param1);
			printf("param2: %8.4f\n",(double)container.param2);
			printf("param3: %8.4f\n",(double)container.param3);
			printf("param4: %8.4f\n",(double)container.param4);
			printf("param5: %8.4f\n",(double)container.param5);
			printf("param6: %8.4f\n",(double)container.param6);
			printf("param7: %8.4f\n",(double)container.param7);
			printf("command: %u\n",(unsigned)container.command);
			printf("target_system: %u\n",(unsigned)container.target_system);
			printf("target_component: %u\n",(unsigned)container.target_component);
			printf("source_system: %u\n",(unsigned)container.source_system);
			printf("source_component: %u\n",(unsigned)container.source_component);
			printf("confirmation: %u\n",(unsigned)container.confirmation);
			printf("from_external: %s\n",container.from_external ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"rc_parameter_map",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(rc_parameter_map), topic_instance);
		ID = ORB_ID(rc_parameter_map);
		struct rc_parameter_map_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: rc_parameter_map instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("param_index: ");
			for (int j = 0; j < 3; j++) {
				printf("%d ",container.param_index[j]);
			}
			printf("\n");
			printf("scale: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.scale[j]);
			}
			printf("\n");
			printf("value0: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.value0[j]);
			}
			printf("\n");
			printf("value_min: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.value_min[j]);
			}
			printf("\n");
			printf("value_max: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.value_max[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"home_position",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(home_position), topic_instance);
		ID = ORB_ID(home_position);
		struct home_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: home_position instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("direction_x: %8.4f\n",(double)container.direction_x);
			printf("direction_y: %8.4f\n",(double)container.direction_y);
			printf("direction_z: %8.4f\n",(double)container.direction_z);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"collision_report",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(collision_report), topic_instance);
		ID = ORB_ID(collision_report);
		struct collision_report_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: collision_report instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("src: %u\n",(unsigned)container.src);
			printf("id: %u\n",container.id);
			printf("action: %u\n",(unsigned)container.action);
			printf("threat_level: %u\n",(unsigned)container.threat_level);
			printf("time_to_minimum_delta: %8.4f\n",(double)container.time_to_minimum_delta);
			printf("altitude_minimum_delta: %8.4f\n",(double)container.altitude_minimum_delta);
			printf("horizontal_minimum_delta: %8.4f\n",(double)container.horizontal_minimum_delta);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"transponder_report",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(transponder_report), topic_instance);
		ID = ORB_ID(transponder_report);
		struct transponder_report_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: transponder_report instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("ICAO_address: %u\n",container.ICAO_address);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("altitude_type: %u\n",(unsigned)container.altitude_type);
			printf("altitude: %8.4f\n",(double)container.altitude);
			printf("heading: %8.4f\n",(double)container.heading);
			printf("hor_velocity: %8.4f\n",(double)container.hor_velocity);
			printf("ver_velocity: %8.4f\n",(double)container.ver_velocity);
			printf("emitter_type: %u\n",(unsigned)container.emitter_type);
			printf("tslc: %u\n",(unsigned)container.tslc);
			printf("flags: %u\n",(unsigned)container.flags);
			printf("squawk: %u\n",(unsigned)container.squawk);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"gps_dump",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(gps_dump), topic_instance);
		ID = ORB_ID(gps_dump);
		struct gps_dump_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: gps_dump instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"esc_report",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(esc_report), topic_instance);
		ID = ORB_ID(esc_report);
		struct esc_report_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: esc_report instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("esc_vendor: %u\n",(unsigned)container.esc_vendor);
			printf("esc_errorcount: %u\n",container.esc_errorcount);
			printf("esc_rpm: %d\n",container.esc_rpm);
			printf("esc_voltage: %8.4f\n",(double)container.esc_voltage);
			printf("esc_current: %8.4f\n",(double)container.esc_current);
			printf("esc_temperature: %8.4f\n",(double)container.esc_temperature);
			printf("esc_setpoint: %8.4f\n",(double)container.esc_setpoint);
			printf("esc_setpoint_raw: %u\n",(unsigned)container.esc_setpoint_raw);
			printf("esc_address: %u\n",(unsigned)container.esc_address);
			printf("esc_version: %u\n",(unsigned)container.esc_version);
			printf("esc_state: %u\n",(unsigned)container.esc_state);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"ulog_stream_ack",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(ulog_stream_ack), topic_instance);
		ID = ORB_ID(ulog_stream_ack);
		struct ulog_stream_ack_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: ulog_stream_ack instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("sequence: %u\n",(unsigned)container.sequence);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"mount_orientation",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(mount_orientation), topic_instance);
		ID = ORB_ID(mount_orientation);
		struct mount_orientation_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: mount_orientation instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("attitude_euler_angle: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.attitude_euler_angle[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"tecs_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(tecs_status), topic_instance);
		ID = ORB_ID(tecs_status);
		struct tecs_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: tecs_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("altitudeSp: %8.4f\n",(double)container.altitudeSp);
			printf("altitude_filtered: %8.4f\n",(double)container.altitude_filtered);
			printf("flightPathAngleSp: %8.4f\n",(double)container.flightPathAngleSp);
			printf("flightPathAngle: %8.4f\n",(double)container.flightPathAngle);
			printf("airspeedSp: %8.4f\n",(double)container.airspeedSp);
			printf("airspeed_filtered: %8.4f\n",(double)container.airspeed_filtered);
			printf("airspeedDerivativeSp: %8.4f\n",(double)container.airspeedDerivativeSp);
			printf("airspeedDerivative: %8.4f\n",(double)container.airspeedDerivative);
			printf("totalEnergyError: %8.4f\n",(double)container.totalEnergyError);
			printf("energyDistributionError: %8.4f\n",(double)container.energyDistributionError);
			printf("totalEnergyRateError: %8.4f\n",(double)container.totalEnergyRateError);
			printf("energyDistributionRateError: %8.4f\n",(double)container.energyDistributionRateError);
			printf("throttle_integ: %8.4f\n",(double)container.throttle_integ);
			printf("pitch_integ: %8.4f\n",(double)container.pitch_integ);
			printf("mode: %u\n",(unsigned)container.mode);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_preflight",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_preflight), topic_instance);
		ID = ORB_ID(sensor_preflight);
		struct sensor_preflight_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_preflight instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("accel_inconsistency_m_s_s: %8.4f\n",(double)container.accel_inconsistency_m_s_s);
			printf("gyro_inconsistency_rad_s: %8.4f\n",(double)container.gyro_inconsistency_rad_s);
			printf("mag_inconsistency_ga: %8.4f\n",(double)container.mag_inconsistency_ga);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_selection",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_selection), topic_instance);
		ID = ORB_ID(sensor_selection);
		struct sensor_selection_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_selection instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("accel_device_id: %u\n",container.accel_device_id);
			printf("baro_device_id: %u\n",container.baro_device_id);
			printf("gyro_device_id: %u\n",container.gyro_device_id);
			printf("mag_device_id: %u\n",container.mag_device_id);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"input_rc",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(input_rc), topic_instance);
		ID = ORB_ID(input_rc);
		struct input_rc_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: input_rc instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_last_signal: %" PRIu64 "\n",container.timestamp_last_signal);
			printf("channel_count: %u\n",container.channel_count);
			printf("rssi: %d\n",container.rssi);
			printf("rc_failsafe: %s\n",container.rc_failsafe ? "True" : "False");
			printf("rc_lost: %s\n",container.rc_lost ? "True" : "False");
			printf("rc_lost_frame_count: %u\n",(unsigned)container.rc_lost_frame_count);
			printf("rc_total_frame_count: %u\n",(unsigned)container.rc_total_frame_count);
			printf("rc_ppm_frame_length: %u\n",(unsigned)container.rc_ppm_frame_length);
			printf("input_source: %u\n",(unsigned)container.input_source);
			printf("values: ");
			for (int j = 0; j < 18; j++) {
				printf("%u ",container.values[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vtol_vehicle_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vtol_vehicle_status), topic_instance);
		ID = ORB_ID(vtol_vehicle_status);
		struct vtol_vehicle_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vtol_vehicle_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("vtol_in_rw_mode: %s\n",container.vtol_in_rw_mode ? "True" : "False");
			printf("vtol_in_trans_mode: %s\n",container.vtol_in_trans_mode ? "True" : "False");
			printf("in_transition_to_fw: %s\n",container.in_transition_to_fw ? "True" : "False");
			printf("vtol_transition_failsafe: %s\n",container.vtol_transition_failsafe ? "True" : "False");
			printf("fw_permanent_stab: %s\n",container.fw_permanent_stab ? "True" : "False");
			printf("airspeed_tot: %8.4f\n",(double)container.airspeed_tot);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"uavcan_parameter_request",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(uavcan_parameter_request), topic_instance);
		ID = ORB_ID(uavcan_parameter_request);
		struct uavcan_parameter_request_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: uavcan_parameter_request instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("message_type: %u\n",(unsigned)container.message_type);
			printf("node_id: %u\n",(unsigned)container.node_id);
			printf("param_index: %d\n",(int)container.param_index);
			printf("param_type: %u\n",(unsigned)container.param_type);
			printf("int_value: %" PRId64 "\n",container.int_value);
			printf("real_value: %8.4f\n",(double)container.real_value);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"power_button_state",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(power_button_state), topic_instance);
		ID = ORB_ID(power_button_state);
		struct power_button_state_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: power_button_state instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("event: %u\n",(unsigned)container.event);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"airspeed",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(airspeed), topic_instance);
		ID = ORB_ID(airspeed);
		struct airspeed_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: airspeed instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("indicated_airspeed_m_s: %8.4f\n",(double)container.indicated_airspeed_m_s);
			printf("true_airspeed_m_s: %8.4f\n",(double)container.true_airspeed_m_s);
			printf("true_airspeed_unfiltered_m_s: %8.4f\n",(double)container.true_airspeed_unfiltered_m_s);
			printf("air_temperature_celsius: %8.4f\n",(double)container.air_temperature_celsius);
			printf("confidence: %8.4f\n",(double)container.confidence);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"cpuload",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(cpuload), topic_instance);
		ID = ORB_ID(cpuload);
		struct cpuload_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: cpuload instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("load: %8.4f\n",(double)container.load);
			printf("ram_usage: %8.4f\n",(double)container.ram_usage);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"debug_key_value",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(debug_key_value), topic_instance);
		ID = ORB_ID(debug_key_value);
		struct debug_key_value_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: debug_key_value instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_ms: %u\n",container.timestamp_ms);
			printf("value: %8.4f\n",(double)container.value);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_local_position",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_local_position), topic_instance);
		ID = ORB_ID(vehicle_local_position);
		struct vehicle_local_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_local_position instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("xy_valid: %s\n",container.xy_valid ? "True" : "False");
			printf("z_valid: %s\n",container.z_valid ? "True" : "False");
			printf("v_xy_valid: %s\n",container.v_xy_valid ? "True" : "False");
			printf("v_z_valid: %s\n",container.v_z_valid ? "True" : "False");
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("delta_xy: ");
			for (int j = 0; j < 2; j++) {
				printf("%8.4f ",(double)container.delta_xy[j]);
			}
			printf("\n");
			printf("xy_reset_counter: %u\n",(unsigned)container.xy_reset_counter);
			printf("delta_z: %8.4f\n",(double)container.delta_z);
			printf("z_reset_counter: %u\n",(unsigned)container.z_reset_counter);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vy: %8.4f\n",(double)container.vy);
			printf("vz: %8.4f\n",(double)container.vz);
			printf("z_deriv: %8.4f\n",(double)container.z_deriv);
			printf("delta_vxy: ");
			for (int j = 0; j < 2; j++) {
				printf("%8.4f ",(double)container.delta_vxy[j]);
			}
			printf("\n");
			printf("vxy_reset_counter: %u\n",(unsigned)container.vxy_reset_counter);
			printf("delta_vz: %8.4f\n",(double)container.delta_vz);
			printf("vz_reset_counter: %u\n",(unsigned)container.vz_reset_counter);
			printf("ax: %8.4f\n",(double)container.ax);
			printf("ay: %8.4f\n",(double)container.ay);
			printf("az: %8.4f\n",(double)container.az);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("xy_global: %s\n",container.xy_global ? "True" : "False");
			printf("z_global: %s\n",container.z_global ? "True" : "False");
			printf("ref_timestamp: %" PRIu64 "\n",container.ref_timestamp);
			printf("ref_lat: %8.4f\n",(double)container.ref_lat);
			printf("ref_lon: %8.4f\n",(double)container.ref_lon);
			printf("ref_alt: %8.4f\n",(double)container.ref_alt);
			printf("dist_bottom: %8.4f\n",(double)container.dist_bottom);
			printf("dist_bottom_rate: %8.4f\n",(double)container.dist_bottom_rate);
			printf("dist_bottom_valid: %s\n",container.dist_bottom_valid ? "True" : "False");
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			printf("evh: %8.4f\n",(double)container.evh);
			printf("evv: %8.4f\n",(double)container.evv);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"gps_inject_data",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(gps_inject_data), topic_instance);
		ID = ORB_ID(gps_inject_data);
		struct gps_inject_data_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: gps_inject_data instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("len: %u\n",(unsigned)container.len);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"uavcan_parameter_value",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(uavcan_parameter_value), topic_instance);
		ID = ORB_ID(uavcan_parameter_value);
		struct uavcan_parameter_value_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: uavcan_parameter_value instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("node_id: %u\n",(unsigned)container.node_id);
			printf("param_index: %d\n",(int)container.param_index);
			printf("param_count: %u\n",(unsigned)container.param_count);
			printf("param_type: %u\n",(unsigned)container.param_type);
			printf("int_value: %" PRId64 "\n",container.int_value);
			printf("real_value: %8.4f\n",(double)container.real_value);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"time_offset",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(time_offset), topic_instance);
		ID = ORB_ID(time_offset);
		struct time_offset_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: time_offset instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("offset_ns: %" PRIu64 "\n",container.offset_ns);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"task_stack_info",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(task_stack_info), topic_instance);
		ID = ORB_ID(task_stack_info);
		struct task_stack_info_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: task_stack_info instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("stack_free: %u\n",(unsigned)container.stack_free);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"commander_state",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(commander_state), topic_instance);
		ID = ORB_ID(commander_state);
		struct commander_state_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: commander_state instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("main_state: %u\n",(unsigned)container.main_state);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"rc_channels",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(rc_channels), topic_instance);
		ID = ORB_ID(rc_channels);
		struct rc_channels_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: rc_channels instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_last_valid: %" PRIu64 "\n",container.timestamp_last_valid);
			printf("channels: ");
			for (int j = 0; j < 18; j++) {
				printf("%8.4f ",(double)container.channels[j]);
			}
			printf("\n");
			printf("channel_count: %u\n",(unsigned)container.channel_count);
			printf("rssi: %u\n",(unsigned)container.rssi);
			printf("signal_lost: %s\n",container.signal_lost ? "True" : "False");
			printf("frame_drop_count: %u\n",container.frame_drop_count);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"satellite_info",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(satellite_info), topic_instance);
		ID = ORB_ID(satellite_info);
		struct satellite_info_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: satellite_info instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("count: %u\n",(unsigned)container.count);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"log_message",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(log_message), topic_instance);
		ID = ORB_ID(log_message);
		struct log_message_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: log_message instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("severity: %u\n",(unsigned)container.severity);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"test_motor",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(test_motor), topic_instance);
		ID = ORB_ID(test_motor);
		struct test_motor_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: test_motor instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("motor_number: %u\n",container.motor_number);
			printf("value: %8.4f\n",(double)container.value);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"qshell_req",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(qshell_req), topic_instance);
		ID = ORB_ID(qshell_req);
		struct qshell_req_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: qshell_req instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("string: ");
			for (int j = 0; j < 100; j++) {
				printf("%d ",container.string[j]);
			}
			printf("\n");
			printf("strlen: %" PRIu64 "\n",container.strlen);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"fw_pos_ctrl_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(fw_pos_ctrl_status), topic_instance);
		ID = ORB_ID(fw_pos_ctrl_status);
		struct fw_pos_ctrl_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: fw_pos_ctrl_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("nav_roll: %8.4f\n",(double)container.nav_roll);
			printf("nav_pitch: %8.4f\n",(double)container.nav_pitch);
			printf("nav_bearing: %8.4f\n",(double)container.nav_bearing);
			printf("target_bearing: %8.4f\n",(double)container.target_bearing);
			printf("wp_dist: %8.4f\n",(double)container.wp_dist);
			printf("xtrack_error: %8.4f\n",(double)container.xtrack_error);
			printf("turn_distance: %8.4f\n",(double)container.turn_distance);
			printf("landing_horizontal_slope_displacement: %8.4f\n",(double)container.landing_horizontal_slope_displacement);
			printf("landing_slope_angle_rad: %8.4f\n",(double)container.landing_slope_angle_rad);
			printf("landing_flare_length: %8.4f\n",(double)container.landing_flare_length);
			printf("abort_landing: %s\n",container.abort_landing ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"camera_capture",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(camera_capture), topic_instance);
		ID = ORB_ID(camera_capture);
		struct camera_capture_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: camera_capture instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_utc: %" PRIu64 "\n",container.timestamp_utc);
			printf("seq: %u\n",container.seq);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			printf("ground_distance: %8.4f\n",(double)container.ground_distance);
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			printf("result: %d\n",(int)container.result);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"servorail_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(servorail_status), topic_instance);
		ID = ORB_ID(servorail_status);
		struct servorail_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: servorail_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("voltage_v: %8.4f\n",(double)container.voltage_v);
			printf("rssi_v: %8.4f\n",(double)container.rssi_v);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"offboard_control_mode",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(offboard_control_mode), topic_instance);
		ID = ORB_ID(offboard_control_mode);
		struct offboard_control_mode_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: offboard_control_mode instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("ignore_thrust: %s\n",container.ignore_thrust ? "True" : "False");
			printf("ignore_attitude: %s\n",container.ignore_attitude ? "True" : "False");
			printf("ignore_bodyrate: %s\n",container.ignore_bodyrate ? "True" : "False");
			printf("ignore_position: %s\n",container.ignore_position ? "True" : "False");
			printf("ignore_velocity: %s\n",container.ignore_velocity ? "True" : "False");
			printf("ignore_acceleration_force: %s\n",container.ignore_acceleration_force ? "True" : "False");
			printf("ignore_alt_hold: %s\n",container.ignore_alt_hold ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_gyro",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_gyro), topic_instance);
		ID = ORB_ID(sensor_gyro);
		struct sensor_gyro_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_gyro instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("integral_dt: %" PRIu64 "\n",container.integral_dt);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("x_integral: %8.4f\n",(double)container.x_integral);
			printf("y_integral: %8.4f\n",(double)container.y_integral);
			printf("z_integral: %8.4f\n",(double)container.z_integral);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("range_rad_s: %8.4f\n",(double)container.range_rad_s);
			printf("scaling: %8.4f\n",(double)container.scaling);
			printf("x_raw: %d\n",(int)container.x_raw);
			printf("y_raw: %d\n",(int)container.y_raw);
			printf("z_raw: %d\n",(int)container.z_raw);
			printf("temperature_raw: %d\n",(int)container.temperature_raw);
			printf("device_id: %u\n",container.device_id);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_rates_setpoint",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_rates_setpoint), topic_instance);
		ID = ORB_ID(vehicle_rates_setpoint);
		struct vehicle_rates_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_rates_setpoint instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("roll: %8.4f\n",(double)container.roll);
			printf("pitch: %8.4f\n",(double)container.pitch);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("thrust: %8.4f\n",(double)container.thrust);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"parameter_update",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(parameter_update), topic_instance);
		ID = ORB_ID(parameter_update);
		struct parameter_update_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: parameter_update instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("dummy: %u\n",container.dummy);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"mavlink_log",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(mavlink_log), topic_instance);
		ID = ORB_ID(mavlink_log);
		struct mavlink_log_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: mavlink_log instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("severity: %u\n",(unsigned)container.severity);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_combined",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_combined), topic_instance);
		ID = ORB_ID(sensor_combined);
		struct sensor_combined_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_combined instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("gyro_rad: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_rad[j]);
			}
			printf("\n");
			printf("gyro_integral_dt: %u\n",container.gyro_integral_dt);
			printf("accelerometer_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer_integral_dt: %u\n",container.accelerometer_integral_dt);
			printf("magnetometer_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_ga[j]);
			}
			printf("\n");
			printf("baro_alt_meter: %8.4f\n",(double)container.baro_alt_meter);
			printf("baro_temp_celcius: %8.4f\n",(double)container.baro_temp_celcius);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_command_ack",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_command_ack), topic_instance);
		ID = ORB_ID(vehicle_command_ack);
		struct vehicle_command_ack_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_command_ack instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("command: %u\n",(unsigned)container.command);
			printf("result: %u\n",(unsigned)container.result);
			printf("from_external: %s\n",container.from_external ? "True" : "False");
			printf("result_param1: %u\n",(unsigned)container.result_param1);
			printf("result_param2: %d\n",container.result_param2);
			printf("target_system: %u\n",(unsigned)container.target_system);
			printf("target_component: %u\n",(unsigned)container.target_component);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"esc_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(esc_status), topic_instance);
		ID = ORB_ID(esc_status);
		struct esc_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: esc_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("counter: %u\n",(unsigned)container.counter);
			printf("esc_count: %u\n",(unsigned)container.esc_count);
			printf("esc_connectiontype: %u\n",(unsigned)container.esc_connectiontype);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"debug_value",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(debug_value), topic_instance);
		ID = ORB_ID(debug_value);
		struct debug_value_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: debug_value instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("timestamp_ms: %u\n",container.timestamp_ms);
			printf("ind: %d\n",(int)container.ind);
			printf("value: %8.4f\n",(double)container.value);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"system_power",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(system_power), topic_instance);
		ID = ORB_ID(system_power);
		struct system_power_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: system_power instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("voltage5V_v: %8.4f\n",(double)container.voltage5V_v);
			printf("voltage3V3_v: %8.4f\n",(double)container.voltage3V3_v);
			printf("v3v3_valid: %u\n",(unsigned)container.v3v3_valid);
			printf("usb_connected: %u\n",(unsigned)container.usb_connected);
			printf("brick_valid: %u\n",(unsigned)container.brick_valid);
			printf("usb_valid: %u\n",(unsigned)container.usb_valid);
			printf("servo_valid: %u\n",(unsigned)container.servo_valid);
			printf("periph_5V_OC: %u\n",(unsigned)container.periph_5V_OC);
			printf("hipower_5V_OC: %u\n",(unsigned)container.hipower_5V_OC);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_mag",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_mag), topic_instance);
		ID = ORB_ID(sensor_mag);
		struct sensor_mag_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_mag instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("range_ga: %8.4f\n",(double)container.range_ga);
			printf("scaling: %8.4f\n",(double)container.scaling);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("x_raw: %d\n",(int)container.x_raw);
			printf("y_raw: %d\n",(int)container.y_raw);
			printf("z_raw: %d\n",(int)container.z_raw);
			printf("device_id: %u\n",container.device_id);
			printf("is_external: %s\n",container.is_external ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_global_position",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_global_position), topic_instance);
		ID = ORB_ID(vehicle_global_position);
		struct vehicle_global_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_global_position instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			printf("delta_alt: %8.4f\n",(double)container.delta_alt);
			printf("lat_lon_reset_counter: %u\n",(unsigned)container.lat_lon_reset_counter);
			printf("alt_reset_counter: %u\n",(unsigned)container.alt_reset_counter);
			printf("vel_n: %8.4f\n",(double)container.vel_n);
			printf("vel_e: %8.4f\n",(double)container.vel_e);
			printf("vel_d: %8.4f\n",(double)container.vel_d);
			printf("pos_d_deriv: %8.4f\n",(double)container.pos_d_deriv);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			printf("evh: %8.4f\n",(double)container.evh);
			printf("evv: %8.4f\n",(double)container.evv);
			printf("terrain_alt: %8.4f\n",(double)container.terrain_alt);
			printf("terrain_alt_valid: %s\n",container.terrain_alt_valid ? "True" : "False");
			printf("pressure_alt: %8.4f\n",(double)container.pressure_alt);
			printf("dead_reckoning: %s\n",container.dead_reckoning ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"battery_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(battery_status), topic_instance);
		ID = ORB_ID(battery_status);
		struct battery_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: battery_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("voltage_v: %8.4f\n",(double)container.voltage_v);
			printf("voltage_filtered_v: %8.4f\n",(double)container.voltage_filtered_v);
			printf("current_a: %8.4f\n",(double)container.current_a);
			printf("current_filtered_a: %8.4f\n",(double)container.current_filtered_a);
			printf("discharged_mah: %8.4f\n",(double)container.discharged_mah);
			printf("remaining: %8.4f\n",(double)container.remaining);
			printf("scale: %8.4f\n",(double)container.scale);
			printf("cell_count: %d\n",container.cell_count);
			printf("connected: %s\n",container.connected ? "True" : "False");
			printf("system_source: %s\n",container.system_source ? "True" : "False");
			printf("priority: %u\n",(unsigned)container.priority);
			printf("warning: %u\n",(unsigned)container.warning);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_roi",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_roi), topic_instance);
		ID = ORB_ID(vehicle_roi);
		struct vehicle_roi_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_roi instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("mode: %u\n",(unsigned)container.mode);
			printf("mission_seq: %u\n",container.mission_seq);
			printf("target_seq: %u\n",container.target_seq);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"distance_sensor",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(distance_sensor), topic_instance);
		ID = ORB_ID(distance_sensor);
		struct distance_sensor_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: distance_sensor instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("min_distance: %8.4f\n",(double)container.min_distance);
			printf("max_distance: %8.4f\n",(double)container.max_distance);
			printf("current_distance: %8.4f\n",(double)container.current_distance);
			printf("covariance: %8.4f\n",(double)container.covariance);
			printf("type: %u\n",(unsigned)container.type);
			printf("id: %u\n",(unsigned)container.id);
			printf("orientation: %u\n",(unsigned)container.orientation);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"att_pos_mocap",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(att_pos_mocap), topic_instance);
		ID = ORB_ID(att_pos_mocap);
		struct att_pos_mocap_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: att_pos_mocap instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("id: %u\n",container.id);
			printf("timestamp_received: %" PRIu64 "\n",container.timestamp_received);
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"led_control",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(led_control), topic_instance);
		ID = ORB_ID(led_control);
		struct led_control_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: led_control instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("led_mask: %u\n",(unsigned)container.led_mask);
			printf("color: %u\n",(unsigned)container.color);
			printf("mode: %u\n",(unsigned)container.mode);
			printf("num_blinks: %u\n",(unsigned)container.num_blinks);
			printf("priority: %u\n",(unsigned)container.priority);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_status), topic_instance);
		ID = ORB_ID(vehicle_status);
		struct vehicle_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("nav_state: %u\n",(unsigned)container.nav_state);
			printf("arming_state: %u\n",(unsigned)container.arming_state);
			printf("hil_state: %u\n",(unsigned)container.hil_state);
			printf("failsafe: %s\n",container.failsafe ? "True" : "False");
			printf("system_type: %u\n",(unsigned)container.system_type);
			printf("system_id: %u\n",(unsigned)container.system_id);
			printf("component_id: %u\n",(unsigned)container.component_id);
			printf("is_rotary_wing: %s\n",container.is_rotary_wing ? "True" : "False");
			printf("is_vtol: %s\n",container.is_vtol ? "True" : "False");
			printf("vtol_fw_permanent_stab: %s\n",container.vtol_fw_permanent_stab ? "True" : "False");
			printf("in_transition_mode: %s\n",container.in_transition_mode ? "True" : "False");
			printf("in_transition_to_fw: %s\n",container.in_transition_to_fw ? "True" : "False");
			printf("rc_signal_lost: %s\n",container.rc_signal_lost ? "True" : "False");
			printf("rc_input_mode: %u\n",(unsigned)container.rc_input_mode);
			printf("data_link_lost: %s\n",container.data_link_lost ? "True" : "False");
			printf("data_link_lost_counter: %u\n",(unsigned)container.data_link_lost_counter);
			printf("engine_failure: %s\n",container.engine_failure ? "True" : "False");
			printf("engine_failure_cmd: %s\n",container.engine_failure_cmd ? "True" : "False");
			printf("mission_failure: %s\n",container.mission_failure ? "True" : "False");
			printf("onboard_control_sensors_present: %u\n",container.onboard_control_sensors_present);
			printf("onboard_control_sensors_enabled: %u\n",container.onboard_control_sensors_enabled);
			printf("onboard_control_sensors_health: %u\n",container.onboard_control_sensors_health);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_land_detected",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_land_detected), topic_instance);
		ID = ORB_ID(vehicle_land_detected);
		struct vehicle_land_detected_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_land_detected instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("landed: %s\n",container.landed ? "True" : "False");
			printf("freefall: %s\n",container.freefall ? "True" : "False");
			printf("ground_contact: %s\n",container.ground_contact ? "True" : "False");
			printf("maybe_landed: %s\n",container.maybe_landed ? "True" : "False");
			printf("alt_max: %8.4f\n",(double)container.alt_max);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_attitude_setpoint",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_attitude_setpoint), topic_instance);
		ID = ORB_ID(vehicle_attitude_setpoint);
		struct vehicle_attitude_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_attitude_setpoint instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("roll_body: %8.4f\n",(double)container.roll_body);
			printf("pitch_body: %8.4f\n",(double)container.pitch_body);
			printf("yaw_body: %8.4f\n",(double)container.yaw_body);
			printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
			printf("q_d: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_d[j]);
			}
			printf("\n");
			printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
			printf("thrust: %8.4f\n",(double)container.thrust);
			printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
			printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
			printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
			printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
			printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
			printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
			printf("landing_gear: %8.4f\n",(double)container.landing_gear);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"actuator_armed",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(actuator_armed), topic_instance);
		ID = ORB_ID(actuator_armed);
		struct actuator_armed_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: actuator_armed instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("armed_time_ms: %u\n",container.armed_time_ms);
			printf("armed: %s\n",container.armed ? "True" : "False");
			printf("prearmed: %s\n",container.prearmed ? "True" : "False");
			printf("ready_to_arm: %s\n",container.ready_to_arm ? "True" : "False");
			printf("lockdown: %s\n",container.lockdown ? "True" : "False");
			printf("manual_lockdown: %s\n",container.manual_lockdown ? "True" : "False");
			printf("force_failsafe: %s\n",container.force_failsafe ? "True" : "False");
			printf("in_esc_calibration_mode: %s\n",container.in_esc_calibration_mode ? "True" : "False");
			printf("soft_stop: %s\n",container.soft_stop ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"ulog_stream",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(ulog_stream), topic_instance);
		ID = ORB_ID(ulog_stream);
		struct ulog_stream_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: ulog_stream instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("length: %u\n",(unsigned)container.length);
			printf("first_message_offset: %u\n",(unsigned)container.first_message_offset);
			printf("sequence: %u\n",(unsigned)container.sequence);
			printf("flags: %u\n",(unsigned)container.flags);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"vehicle_control_mode",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(vehicle_control_mode), topic_instance);
		ID = ORB_ID(vehicle_control_mode);
		struct vehicle_control_mode_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: vehicle_control_mode instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("flag_armed: %s\n",container.flag_armed ? "True" : "False");
			printf("flag_external_manual_override_ok: %s\n",container.flag_external_manual_override_ok ? "True" : "False");
			printf("flag_system_hil_enabled: %s\n",container.flag_system_hil_enabled ? "True" : "False");
			printf("flag_control_manual_enabled: %s\n",container.flag_control_manual_enabled ? "True" : "False");
			printf("flag_control_auto_enabled: %s\n",container.flag_control_auto_enabled ? "True" : "False");
			printf("flag_control_offboard_enabled: %s\n",container.flag_control_offboard_enabled ? "True" : "False");
			printf("flag_control_rates_enabled: %s\n",container.flag_control_rates_enabled ? "True" : "False");
			printf("flag_control_attitude_enabled: %s\n",container.flag_control_attitude_enabled ? "True" : "False");
			printf("flag_control_rattitude_enabled: %s\n",container.flag_control_rattitude_enabled ? "True" : "False");
			printf("flag_control_force_enabled: %s\n",container.flag_control_force_enabled ? "True" : "False");
			printf("flag_control_acceleration_enabled: %s\n",container.flag_control_acceleration_enabled ? "True" : "False");
			printf("flag_control_velocity_enabled: %s\n",container.flag_control_velocity_enabled ? "True" : "False");
			printf("flag_control_position_enabled: %s\n",container.flag_control_position_enabled ? "True" : "False");
			printf("flag_control_altitude_enabled: %s\n",container.flag_control_altitude_enabled ? "True" : "False");
			printf("flag_control_climb_rate_enabled: %s\n",container.flag_control_climb_rate_enabled ? "True" : "False");
			printf("flag_control_termination_enabled: %s\n",container.flag_control_termination_enabled ? "True" : "False");
			printf("flag_control_fixed_hdg_enabled: %s\n",container.flag_control_fixed_hdg_enabled ? "True" : "False");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"follow_target",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(follow_target), topic_instance);
		ID = ORB_ID(follow_target);
		struct follow_target_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: follow_target instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			printf("vy: %8.4f\n",(double)container.vy);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vz: %8.4f\n",(double)container.vz);
			printf("est_cap: %u\n",(unsigned)container.est_cap);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"mc_att_ctrl_status",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(mc_att_ctrl_status), topic_instance);
		ID = ORB_ID(mc_att_ctrl_status);
		struct mc_att_ctrl_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: mc_att_ctrl_status instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("roll_rate_integ: %8.4f\n",(double)container.roll_rate_integ);
			printf("pitch_rate_integ: %8.4f\n",(double)container.pitch_rate_integ);
			printf("yaw_rate_integ: %8.4f\n",(double)container.yaw_rate_integ);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"wind_estimate",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(wind_estimate), topic_instance);
		ID = ORB_ID(wind_estimate);
		struct wind_estimate_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: wind_estimate instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("windspeed_north: %8.4f\n",(double)container.windspeed_north);
			printf("windspeed_east: %8.4f\n",(double)container.windspeed_east);
			printf("variance_north: %8.4f\n",(double)container.variance_north);
			printf("variance_east: %8.4f\n",(double)container.variance_east);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"ekf2_timestamps",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(ekf2_timestamps), topic_instance);
		ID = ORB_ID(ekf2_timestamps);
		struct ekf2_timestamps_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: ekf2_timestamps instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("gps_timestamp_rel: %d\n",(int)container.gps_timestamp_rel);
			printf("optical_flow_timestamp_rel: %d\n",(int)container.optical_flow_timestamp_rel);
			printf("distance_sensor_timestamp_rel: %d\n",(int)container.distance_sensor_timestamp_rel);
			printf("airspeed_timestamp_rel: %d\n",(int)container.airspeed_timestamp_rel);
			printf("vision_position_timestamp_rel: %d\n",(int)container.vision_position_timestamp_rel);
			printf("vision_attitude_timestamp_rel: %d\n",(int)container.vision_attitude_timestamp_rel);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"optical_flow",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(optical_flow), topic_instance);
		ID = ORB_ID(optical_flow);
		struct optical_flow_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: optical_flow instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("sensor_id: %u\n",(unsigned)container.sensor_id);
			printf("pixel_flow_x_integral: %8.4f\n",(double)container.pixel_flow_x_integral);
			printf("pixel_flow_y_integral: %8.4f\n",(double)container.pixel_flow_y_integral);
			printf("gyro_x_rate_integral: %8.4f\n",(double)container.gyro_x_rate_integral);
			printf("gyro_y_rate_integral: %8.4f\n",(double)container.gyro_y_rate_integral);
			printf("gyro_z_rate_integral: %8.4f\n",(double)container.gyro_z_rate_integral);
			printf("ground_distance_m: %8.4f\n",(double)container.ground_distance_m);
			printf("integration_timespan: %u\n",container.integration_timespan);
			printf("time_since_last_sonar_update: %u\n",container.time_since_last_sonar_update);
			printf("frame_count_since_last_readout: %u\n",(unsigned)container.frame_count_since_last_readout);
			printf("gyro_temperature: %d\n",(int)container.gyro_temperature);
			printf("quality: %u\n",(unsigned)container.quality);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"mission_result",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(mission_result), topic_instance);
		ID = ORB_ID(mission_result);
		struct mission_result_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: mission_result instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("instance_count: %u\n",container.instance_count);
			printf("seq_reached: %u\n",container.seq_reached);
			printf("seq_current: %u\n",container.seq_current);
			printf("seq_total: %u\n",container.seq_total);
			printf("valid: %s\n",container.valid ? "True" : "False");
			printf("warning: %s\n",container.warning ? "True" : "False");
			printf("reached: %s\n",container.reached ? "True" : "False");
			printf("finished: %s\n",container.finished ? "True" : "False");
			printf("failure: %s\n",container.failure ? "True" : "False");
			printf("stay_in_failsafe: %s\n",container.stay_in_failsafe ? "True" : "False");
			printf("flight_termination: %s\n",container.flight_termination ? "True" : "False");
			printf("item_do_jump_changed: %s\n",container.item_do_jump_changed ? "True" : "False");
			printf("item_changed_index: %u\n",container.item_changed_index);
			printf("item_do_jump_remaining: %u\n",container.item_do_jump_remaining);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"output_pwm",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(output_pwm), topic_instance);
		ID = ORB_ID(output_pwm);
		struct output_pwm_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: output_pwm instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("values: ");
			for (int j = 0; j < 16; j++) {
				printf("%u ",container.values[j]);
			}
			printf("\n");
			printf("channel_count: %u\n",container.channel_count);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"sensor_bias",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(sensor_bias), topic_instance);
		ID = ORB_ID(sensor_bias);
		struct sensor_bias_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: sensor_bias instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("gyro_x: %8.4f\n",(double)container.gyro_x);
			printf("gyro_y: %8.4f\n",(double)container.gyro_y);
			printf("gyro_z: %8.4f\n",(double)container.gyro_z);
			printf("accel_x: %8.4f\n",(double)container.accel_x);
			printf("accel_y: %8.4f\n",(double)container.accel_y);
			printf("accel_z: %8.4f\n",(double)container.accel_z);
			printf("mag_x: %8.4f\n",(double)container.mag_x);
			printf("mag_y: %8.4f\n",(double)container.mag_y);
			printf("mag_z: %8.4f\n",(double)container.mag_z);
			printf("gyro_x_bias: %8.4f\n",(double)container.gyro_x_bias);
			printf("gyro_y_bias: %8.4f\n",(double)container.gyro_y_bias);
			printf("gyro_z_bias: %8.4f\n",(double)container.gyro_z_bias);
			printf("accel_x_bias: %8.4f\n",(double)container.accel_x_bias);
			printf("accel_y_bias: %8.4f\n",(double)container.accel_y_bias);
			printf("accel_z_bias: %8.4f\n",(double)container.accel_z_bias);
			printf("mag_x_bias: %8.4f\n",(double)container.mag_x_bias);
			printf("mag_y_bias: %8.4f\n",(double)container.mag_y_bias);
			printf("mag_z_bias: %8.4f\n",(double)container.mag_z_bias);
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else if (strncmp(argv[1],"actuator_outputs",50) == 0) {
		sub = orb_subscribe_multi(ORB_ID(actuator_outputs), topic_instance);
		ID = ORB_ID(actuator_outputs);
		struct actuator_outputs_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		hrt_abstime start_time = hrt_absolute_time();
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			if (updated) {
			start_time = hrt_absolute_time();
			i++;
			printf("\nTOPIC: actuator_outputs instance %d #%d\n", topic_instance, i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n", container.timestamp);
			printf("noutputs: %u\n",container.noutputs);
			printf("output: ");
			for (int j = 0; j < 16; j++) {
				printf("%8.4f ",(double)container.output[j]);
			}
			printf("\n");
			} else {
				if (check_timeout(start_time)) {
					break;
				}
			}
		}
	} else {
		 printf(" Topic did not match any known topics\n");
	}
		orb_unsubscribe(sub);
	 return 0;
}
